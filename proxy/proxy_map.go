// Package proxy safe map
// Code generated by mapgen (https://github.com/ammario/mapgen), DO NOT EDIT.
package proxy

import "sync"

// StringBoolMap is a generated thread safe map
// with key string and value bool
type StringBoolMap struct {
	sync.RWMutex

	// M contains the underlying map.
	// Goroutines which access M directly should hold
	// the mutex.
	M map[string]bool
}

// NewStringBoolMap returns an instantiated thread safe map
// with key string and value bool
func NewStringBoolMap() *StringBoolMap {
	return &StringBoolMap{
		M: make(map[string]bool),
	}
}

// Open allows a closure to safely operate on the map
func (m *StringBoolMap) Open(f func()) {
	m.Lock()
	defer m.Unlock()
	f()
}

// Copy generates a copy of the map.
func (m *StringBoolMap) Copy() (c map[string]bool) {
	c = make(map[string]bool, len(m.M))

	m.RLock()

	for k, v := range m.M {
		c[k] = v
	}

	m.RUnlock()

	return c
}

// Set sets a key on the map
func (m *StringBoolMap) Set(key string, val bool) {
	m.Lock()
	m.M[key] = val
	m.Unlock()
}

// SetIfNotExist sets a key on the map if it doesn't exist.
// It returns the value which is set.
func (m *StringBoolMap) SetIfNotExist(key string, val bool) bool {
	m.Lock()
	v, ok := m.M[key]
	if !ok {
		m.M[key] = val
	} else {
		val = v
	}
	m.Unlock()
	return val
}

// Delete removes a key from the map
func (m *StringBoolMap) Delete(key string) {
	m.Lock()
	delete(m.M, key)
	m.Unlock()
}

// Get retrieves a key from the map
func (m *StringBoolMap) Get(key string) bool {

	m.RLock()
	v := m.M[key]
	m.RUnlock()

	return v
}

// Len returns the length of the map
func (m *StringBoolMap) Len() int {

	m.RLock()
	n := len(m.M)
	m.RUnlock()

	return n
}

// GetEx retrieves a key from the map
// and whether it exists
func (m *StringBoolMap) GetEx(key string) (bool, bool) {

	m.RLock()
	v, exists := m.M[key]
	m.RUnlock()

	return v, exists
}

// Exists returns if a key exists
func (m *StringBoolMap) Exists(key string) bool {

	m.RLock()
	_, exists := m.M[key]
	m.RUnlock()

	return exists
}
